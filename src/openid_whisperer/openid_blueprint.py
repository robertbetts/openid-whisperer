""" Flask Blueprint with OpenID compatible endpoints
"""
import logging
import json
from flask import Blueprint, request, make_response, render_template, redirect, abort
from flask.typing import ResponseReturnValue
from werkzeug.exceptions import BadRequestKeyError, Unauthorized

from openid_whisperer import openid_lib, openid_api
from openid_whisperer.config import IDP_BASE_URL
from openid_whisperer.openid_api import AuthenticationProcessError

logger = logging.getLogger()
openid_prefix: str = "/adfs"
openid_blueprint: Blueprint = Blueprint('openid', __name__,
                                        url_prefix=openid_prefix,
                                        template_folder='templates',
                                        static_folder='static')


@openid_blueprint.route("/oauth2/authorize", methods=["GET"])  # type: ignore[misc]
def authorize_get() -> ResponseReturnValue:
    """ Handles get requests to the authorization endpoint, this would typically
        be to initiate human interaction required for a particular authorization
        flow.

        https://learn.microsoft.com/en-us/windows-server/identity/ad-fs/overview/ad-fs-openid-connect-oauth-flows-scenarios

        client_id: required
            The client identifier of an initiating application
        response_type: required
            Defines type of authorization flow. Must include
            id_token for OpenID Connect sign-in. It may also include the
            response_type token. Using token here allows your app to receive an
            access token immediately from the authorize endpoint without having
            to make a second request to the token endpoint.
        redirect_uri: required
            The redirect_uri of your app, where
            authentication responses can be sent and received by your app.
        nonce: required
            A value included in the request, generated by the
            app that is to be included in the resulting id_token as a claim.
            The app can then verify this value to mitigate token replay
            attacks. The value is typically a randomized, unique string that
            can be used to identify the origin of the request. Only required
            when an id_token is requested.
        prompt: optional
            Space separated string specifying user prompts for
            re-authentication and consent. Values could be "none", "login",
            "consent" or "select_account"
        scope: optional
            A space-separated list of scopes. For OpenID
            Connect, it must include the scope openid.
        resource: optional
            A uri belonging the client_id indicating a
            permission context. Note: If using MSAL client library, then
            resource parameter isn't sent. Instead, the resource url is sent
            as a part of the scope parameter:
                scope = [resource url]//[scope values e.g., openid]
                If resource isn't passed here or in scope, AD FS uses a default
                resource
                urn:microsoft:userinfo. userinfo resource policies such as MFA,
                Issuance or authorization policy, can't be customized.
        response_mode: optional
            Specifies the method that should be used to
            send the resulting token back to your app. Defaults to fragment.
            Possible values are query or fragment. The draft extension — JWT
            Secured Authorization Response Mode for OAuth 2.0 defines additional
            response modes, query.jwt, fragment.jwt, form_post.jwt or jwt.
        state: optional
            A value included in the request that must also be
            returned with the token response. It can be a string of any content
            that you wish. A randomly generated unique value is typically used
            for preventing cross-site request forgery attacks. The state is
            also used to encode information about the user's state in the app
            before the authentication request occurred, such as the page or
            view they were on.
        rcode: optional
            The authorization_code that the app requested. The app can use
            the authorization code to request an access token for the target
            resource. Authorization_codes are short-lived, typically they
            expire after about 10 minutes.
        state: optional
            If a state parameter is included in the request, the
            same value should appear in the response. The app should verify that
            the state values in the request and response are identical.
        code_challenge_method: optional
            “plain” (default) or “S256”. Can be used if code_challenge is
            sent. Defaults to “plain”. Needs to be sent if S256 is used as
            code_challenge method.
        code_challenge: optional
            A high entropy random challenge. A challenge generated by the client,
            if sent, the code_verifier must be sent on the token call. *Required
            when client must do PKCE (RFC7636).
    """

    scope: str = ""
    response_type: str = ""
    client_id: str = ""
    resource: str
    redirect_uri: str
    state: str
    nonce: str
    prompt: str
    code_challenge_method: str
    code_challenge: str

    try:
        # Get mandatory arguments
        scope = request.args['scope']
        response_type = request.args['response_type']
        client_id = request.args['client_id']
    except BadRequestKeyError as e:
        error_message = f"Invalid input, missing query parameter {e.args[0]}. " \
                        "scope, response_type, client_id are all required parameters"
        logger.debug(error_message)
        abort(403, error_message)

    # Get optional arguments
    resource = request.args.get('resource', "")
    redirect_uri = request.args.get('redirect_uri', "")
    nonce = request.args.get('nonce', "")
    state = request.args.get('state', "")
    response_mode = request.args.get('response_mode', "")
    prompt = request.args.get('prompt', "")
    code_challenge_method = request.args.get('code_challenge_method', "")
    code_challenge = request.args.get('code_challenge', "")

    action = f"?scope={scope}&response_type={response_type}&response_mode={response_mode}&client_id={client_id}"\
             f"&resource={resource}&redirect_uri={redirect_uri}&nonce={nonce}&state={state}&prompt={prompt}" \
             f"&code_challenge_method={code_challenge_method}&code_challenge={code_challenge}"

    resp = make_response(render_template('login.html',
                                         action=action,
                                         client_id=None,
                                         redirect_uri=None,
                                         response_mode=response_mode,
                                         reponse_type=response_type,
                                         prompt=prompt,
                                         code_challenge_method=code_challenge_method,
                                         code_challenge=code_challenge))
    return resp


@openid_blueprint.route("/oauth2/authorize", methods=["POST"])  # type: ignore[misc]
def authorize_post() -> ResponseReturnValue:
    """ Handles an authorization POST request and returns an authorization response

        Where an error arises relating to the processing this request, error_code and error_description are
        appended to the response.
    """
    response_type: str = request.args.get("response_type", "")
    response_mode: str = request.args.get("response_mode", "")
    client_id: str = request.args.get("resource", "")
    client_secret: str = request.args.get("client_secret", "")
    scope: str = request.args.get("scope", "")

    resource: str = request.args.get("resource", "")
    redirect_uri: str = request.args.get("redirect_uri", "")
    nonce: str = request.args.get("nonce", "")
    state: str = request.args.get("state", "")
    prompt: str = request.args.get("prompt", "")

    grant_type: str = request.form.get("grant_type")  # password
    username = request.form.get("UserName")
    user_secret = request.form.get("Password")
    mfa = request.form.get("Mfa", "")
    kmsi = request.form.get("Kmsi", "")
    code_challenge_method: str = request.form.get("code_challenge_method", "")
    code_challenge: str = request.form.get("CodeChallenge", "")

    try:
        openid_response = openid_api.process_end_user_authentication(
            response_type=response_type,
            response_mode=response_mode,
            client_id=client_id,
            client_secret=client_secret,
            scope=scope,
            redirect_uri=redirect_uri,
            nonce=nonce,
            username=username,
            user_secret=user_secret,
            resource=resource,
            state=state,
            mfa=mfa,
            kmsi=kmsi,
            prompt=prompt,
            code_challenge_method=code_challenge_method,
            code_challenge=code_challenge
        )
    except AuthenticationProcessError as e:
        openid_response = {
            "error_code": "AuthenticationProcessError",
            "error_description": str(e)
        }

    if "code" in response_type:

        query_start = "&" if "?" in redirect_uri else "?"

        if "error_code" in openid_response:
            error_code = openid_response['error_code']
            error_description = openid_response.get('error_description')
            redirect_uri = f"{redirect_uri}{query_start}error_code={error_code}&error_description={error_description}"
        else:
            authorisation_code = openid_response["authorisation_code"]
            redirect_uri = f"{redirect_uri}{query_start}code={authorisation_code}&state={state}"

        # TODO: Research and handle cases where redirect should be replaced by a form_post
        return redirect(redirect_uri, code=302)

    elif "token" in response_type:
        if "error_code" in openid_response:
            error_code = openid_response['error_code']
            error_description = openid_response.get('error_description')
            response = {
                "error_code": error_code,
                "error_description": error_description
            }
        else:
            response = openid_response["access_token"]
        return json.dumps(response)

    elif "error_code" in openid_response:
        # TODO: see about when to rather redirect to redirect_uri with error details
        error_code = openid_response['error_code']
        error_description = openid_response.get('error_description')
        abort(403, f"{error_code}: {error_description}")

    else:
        # TODO: see about when to rather redirect to redirect_uri with error details
        abort(403, f"InvalidResponseType: response_type value of '{response_type}' is not supported. A call to "
                   f"/.well-known/openid-configuration will provide information on supported response types")


@openid_blueprint.route("/oauth2/token", methods=["POST"])  # type: ignore[misc]
def token() -> ResponseReturnValue:
    """ returns an access token that can be used to access the client_id resource

        client_id	required	The Application (client) ID that the AD FS
            assigned to your app.
        grant_type	required	Must be authorization_code for the
            authorization code flow.
        code	required	The authorization_code that you acquired in the
            first leg of the flow.
        redirect_uri	required	The same redirect_uri value that was used
            to acquire the authorization_code.
        client_secret	required for web apps The application secret that you
            created during app registration in AD FS. You shouldn't use the
            application secret in a native app because client_secrets can't be
            reliably stored on devices. It's required for web apps and web
            APIs, which have the ability to store the client_secret securely on
            the server side. The client secret must be URL-encoded before being
            sent. These apps can also use a key based authentication by signing
            a JWT and adding that as client_assertion parameter.
        resource optional   The url of your Web API.
            Note – If using MSAL client library, then resource parameter isn't sent. Instead, the resource url is sent
            as a part of the scope parameter: scope = [resource url]//[scope values e.g., openid]
            If resource isn't passed here or in scope, AD FS uses a default resource urn:microsoft:userinfo. userinfo
            resource policies such as MFA, Issuance or authorization policy, can't be customized.
        scope   optional    A space-separated list of scopes.
        code_verifier	optional	The same code_verifier that was used to
            obtain the authorization_code. Required if PKCE was used in the
            authorization code grant request. For more information, see the
            PKCE RFC. This option applies to AD FS 2019 and later
    """
    grant_type: str = request.form["grant_type"]
    if grant_type.endswith("device_code"):
        device_code: str = request.form["device_code"]
        client_id: str = request.form["client_id"]
        if device_code in openid_lib.authorisation_codes:
            response = openid_lib.get_access_token_from_authorisation_code(device_code)
        else:
            user_code = openid_lib.device_user_codes.get(device_code)
            if user_code:
                device_request = openid_lib.device_code_requests.get(user_code)
                # TODO: handle additional error states and device_code cache cleanup
                # Possible additional error states are: authorization_declined, expired_token
                response = {
                    "error": "authorization_pending",
                    "error_description": "Authentication with user_code has not been completed"
                }
            else:
                response = {
                    "error": "bad_verification_code",
                    "error_description": "device code is not recognised"
                }

    # TODO: handle grant_type for on-behalf-of flow
    # elif grant_type.endswith("jwt-bearer"):
    #     # For on-behalf-of flow
    #     client_id: str = request.form["client_id"]
    #     client_secret = request.form.get("client_secret", "")
    #
    #     # urn:ietf:params:oauth:client-assertion-type:jwt-bearer
    #     # client_secret is no required when client_assertion used
    #     client_assertion_type = request.form.get("client_assertion_type", "")
    #     client_assertion = request.form.get("client_assertion", "")
    #
    #     assertion = request.form["assertion"]
    #     requested_token_use = request.form["requested_token_use"]
    #     resource = request.form["resource"]  # second api resource uri
    #     scope = request.form["scope"]

    elif grant_type == "authorization_code":
        # check specifications for handling redirect_uri and compare with openid specs MS reference below:
        # https://learn.microsoft.com/en-us/windows-server/identity/ad-fs/overview/ad-fs-openid-connect-oauth-flows-scenarios
        # redirect_uri: str = request.args.get("redirect_uri", "")

        # client_id: str | None = request.form["client_id"]
        code: str = request.form["code"] if request.form["code"] else ""
        # redirect_uri: str | None = request.form["redirect_uri"]
        # client_secret: str | None = request.form["client_secret"]
        # code_verifier: str | None = request.form["code_verifier"]
        response = openid_lib.get_access_token_from_authorisation_code(code)

    elif grant_type == "password":
        username = request.form["username"]
        user_secret = request.form["password"]
        nonce = request.form.get("nonce", "")
        scope = request.form.get("scope", "")
        access_token_response = openid_lib.authenticate_token(
            client_id=request.form["client_id"],
            resource=request.form.get("resource", ""),
            username=username,
            user_secret=user_secret,
            nonce=nonce,
            scope=scope
        )
        if access_token_response is None:
            response = {
                "error": "invalid_grant",
                "error_description": "MSIS9659: Invalid 'username' or 'password'."
            }
        else:
            response = access_token_response

    else:
        response = {
            "error": "invalid_grant",
            "error_description": f"unsupported grant_type: {grant_type}"
        }

    return json.dumps(response)


@openid_blueprint.route("/oauth2/userinfo", methods=["POST"])  # type: ignore[misc]
def userinfo() -> ResponseReturnValue:
    """ returns claims about the authenticated user
    """
    return ""


@openid_blueprint.route("/oauth2/devicecode", methods=["POST"])  # type: ignore[misc]
def devicecode() -> ResponseReturnValue:
    """ returns the device code and user code
    """
    try:
        client_id = request.form["client_id"]
        scope = request.form["scope"]
        resource = request.form.get("resource", "")
        response = openid_lib.devicecode_request(IDP_BASE_URL, openid_prefix, client_id, scope, resource)
    except KeyError as e:
        response = {
            "error": "bad_devicecode_request",
            "error_description": str(e)
        }
    return json.dumps(response)


@openid_blueprint.route("/oauth2/v2.0/logout", methods=["GET"])  # type: ignore[misc]
@openid_blueprint.route("/oauth2/logout", methods=["POST"])  # type: ignore[misc]
def logout() -> ResponseReturnValue:
    """ logs out the user
    """
    post_logout_redirect_uri = request.args["post_logout_redirect_uri"]
    return redirect(post_logout_redirect_uri, code=302)


@openid_blueprint.route("/discovery/keys", methods=["GET"])  # type: ignore[misc]
def keys() -> ResponseReturnValue:
    """ public keys used to sign responses
    """
    return json.dumps(
        openid_lib.get_keys()
    )


@openid_blueprint.route("/.well-known/openid-configuration", methods=["GET"])  # type: ignore[misc]
def openid_configuration() -> ResponseReturnValue:
    """ returns OAuth/OpenID Connect metadata
    """
    return json.dumps(openid_lib.get_openid_configuration(IDP_BASE_URL, openid_prefix))
